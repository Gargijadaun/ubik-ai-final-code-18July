<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>UBIK Solutions Quiz</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet" />
  <style>
    body {
      font-family: 'Roboto', sans-serif;
      background-color: #f5f5f5;
      margin: 0;
      padding: 0;
    }
    .header {
      background-color: white;
      padding: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .header-logo {
      font-size: 1.5rem;
      font-weight: bold;
    }
    .header-logo span {
      color: #E91E63;
    }
    .container {
      max-width: 600px;
      margin: auto;
      padding: 2rem;
      display: flex;
      flex-direction: column;
    }
    #avatar-container {
      width: 100%;
      height: 250px;
      background: url('/static/ubik-01.jpg') center/cover;
      border-radius: 12px;
      overflow: hidden;
      position: relative;
    }
    #avatar-canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    .quiz-buttons {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin-top: 1rem;
      margin-bottom: 1rem;
    }
    .quiz-buttons button {
      display: flex;
      align-items: center;
      background-color: #E91E63;
      color: white;
      border: none;
      border-radius: 8px;
      padding: 10px 16px;
      font-weight: 500;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s ease;
      gap: 8px;
    }
    .quiz-buttons button:hover {
      background-color: #d81b60;
    }
    .quiz-buttons .icon {
      width: 20px;
      height: 20px;
    }
    .quiz-box {
      background: white;
      border-radius: 12px;
      padding: 1rem;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
    }
    .question-area h2 {
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 0.5rem;
    }
    .question-area p {
      font-size: 16px;
      margin-bottom: 1rem;
    }
    .input-area {
      display: flex;
      flex-direction: column;
      background: #f9f9f9;
      border: 1px solid #ddd;
      border-radius: 12px;
      padding: 12px;
    }
    .input-area .options {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 10px;
    }
    .input-area .option {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .input-area input[type="radio"] {
      margin: 0;
    }
    .input-area label {
      font-size: 16px;
    }
    .input-area button {
      background: #E91E63;
      border: none;
      border-radius: 8px;
      padding: 10px;
      color: white;
      font-weight: 500;
      font-size: 14px;
      cursor: pointer;
      align-self: flex-end;
    }
    .input-area button:hover {
      background-color: #d81b60;
    }
    .nav-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 1.5rem;
    }
    .nav-buttons button {
      flex: 1;
      margin: 0 5px;
      padding: 12px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 14px;
      background-color: white;
      color: #E91E63;
      border: 2px solid #E91E63;
      cursor: pointer;
    }
    .nav-buttons button.active {
      background-color: #E91E63;
      color: white;
    }
    .results {
      margin-top: 1rem;
      background: #fce4ec;
      padding: 1rem;
      border-radius: 12px;
      display: none;
      border-left: 4px solid #E91E63;
    }
    .summary-report {
      margin-top: 1rem;
      background: #e1f5fe;
      padding: 1rem;
      border-radius: 12px;
      display: none;
      border-left: 4px solid #E91E63;
    }
    .summary-report h3 {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 0.5rem;
    }
    .summary-report p {
      font-size: 14px;
      margin-bottom: 0.5rem;
    }
    #waveform {
      display: none;
      margin-top: 10px;
    }
    #waveform .dot {
      width: 12px;
      height: 12px;
      background-color: #E91E63;
      border-radius: 50%;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); opacity: 0.8; }
      50% { transform: scale(1.8); opacity: 0.4; }
      100% { transform: scale(1); opacity: 0.8; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
  <header class="header">
    <div class="header-logo">UBIK <span>SOLUTIONS</span></div>
    <div class="header-logo">AI <span>DERMAT</span></div>
  </header>
  <div class="container">
    <div id="avatar-container">
      <canvas id="avatar-canvas"></canvas>
    </div>
    <div class="quiz-buttons">
      <button onclick="repeatQuestion()">
        <img src="/static/repeat.png" alt="Repeat" class="icon" /> Repeat
      </button>
      <button onclick="startListening()">
        <img src="/static/mic.png" alt="Record" class="icon" /> Record
      </button>
      <button onclick="skipQuestion()">
        <img src="/static/skip.png" alt="Skip" class="icon" /> Skip
      </button>
    </div>
    <div class="quiz-box">
      <div id="question-area" class="question-area">
        <h2>Question <span id="questionNumber">1</span></h2>
        <p id="questionText">Loading question...</p>
      </div>
      <div class="input-area">
        <div id="options" class="options"></div>
        <button onclick="submitAnswer()">Submit</button>
        <div id="waveform"><div class="dot"></div></div>
      </div>
      <div id="results" class="results">
        <h3>Quiz Results</h3>
        <div id="feedback"></div>
      </div>
      <div id="summary-report" class="summary-report">
        <h3>Quiz Summary Report</h3>
        <div id="summary-content"></div>
      </div>
    </div>
    <div class="nav-buttons">
      <button onclick="location.href='/'">AI Assist</button>
      <button class="active" onclick="location.href='/quiz'">AI Dermat</button>
    </div>
  </div>
  <script>
    let mixer, clock = new THREE.Clock();
    let animations = {};
    let rootBone = null;
    let morphDict, morphInfluences;
    let isSpeaking = false;
    let isListening = false;
    let questions = [];
    let currentQuestion = 0;
    let totalQuestions = 5;
    let answers = [];
    let model, renderer, scene, camera;

    function loadModelAnimations(gltf) {
      mixer = new THREE.AnimationMixer(gltf.scene);
      console.log("Available animations:", gltf.animations.map(clip => clip.name));
      if (gltf.animations.length > 0) {
        animations.Idle = mixer.clipAction(gltf.animations[0]);
        animations.Idle.setLoop(THREE.LoopRepeat);
        animations.Idle.play();
        console.log(`Playing first animation: ${gltf.animations[0].name}`);
      } else {
        console.warn("No animations found in GLB file.");
      }
      gltf.scene.traverse(child => {
        if (child.isBone && child.name.toLowerCase().includes("root")) {
          rootBone = child;
        }
      });
      console.log("Loaded animations:", Object.keys(animations));
    }

    function playTalkingAnimation() {
      if (!mixer || !animations.Idle) {
        console.warn("No animation available for talking, using blend shapes only");
        return;
      }
      animations.Idle.play();
      console.log("Playing animation for talking");
    }

    function stopTalkingAnimation() {
      if (animations.Idle) {
        animations.Idle.play();
        console.log("Ensuring animation is playing");
      } else {
        console.log("No animation to play");
      }
    }

    function startMouthAnimation() {
      if (!morphDict || !morphInfluences) {
        console.warn("No morph targets available");
        return;
      }
      const index = morphDict['mouthOpen'];
      if (index === undefined) {
        console.warn("mouthOpen blend shape not found");
        return;
      }
      clearInterval(window.mouthInterval);
      window.mouthInterval = setInterval(() => {
        const t = performance.now() / 100;
        const value = Math.abs(Math.sin(t)) * 0.8;
        morphInfluences[index] = value;
      }, 100);
    }

    function stopMouthAnimation() {
      if (morphDict && morphInfluences && morphDict['mouthOpen'] !== undefined) {
        morphInfluences[morphDict['mouthOpen']] = 0;
      }
      clearInterval(window.mouthInterval);
      console.log("Stopped mouth animation");
    }

    function animateAvatar() {
      requestAnimationFrame(animateAvatar);
      const delta = clock.getDelta();
      if (mixer) {
        try {
          mixer.update(delta);
          console.log("Animation mixer updated");
        } catch (error) {
          console.error("Error updating animation mixer:", error);
        }
      }
      if (rootBone) rootBone.rotation.y = 0;
    }
    animateAvatar();

    function initAvatar() {
      const canvas = document.getElementById('avatar-canvas');
      const container = document.getElementById('avatar-container');
      const bounds = container.getBoundingClientRect();

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(30, bounds.width / bounds.height, 0.01, 5000);
      camera.position.set(0, 0, 3.5);

      renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true,
        alpha: true
      });
      renderer.setSize(bounds.width, bounds.height);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.shadowMap.enabled = true;
      renderer.toneMapping = THREE.NoToneMapping;
      renderer.toneMappingExposure = 1.2;
      renderer.setClearColor(0x000000, 0);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.target.set(0, 0, 0);
      controls.enableZoom = false;
      controls.enablePan = false;
      controls.enableRotate = false;
      controls.update();

      const loader = new THREE.GLTFLoader();
      loader.load('static/male_char_LightBaked_15thJuly.glb', function (gltf) {
        model = gltf.scene;
        model.position.set(0, -4.7, 0);
        model.rotation.set(0, 0.1, 0);
        model.scale.set(3, 3, 3);
        console.log('Model Position after setting:', model.position);
        scene.add(model);

        loadModelAnimations(gltf);

        let skinnedMesh;
        model.traverse(child => {
          if (child.isSkinnedMesh && child.morphTargetDictionary) {
            skinnedMesh = child;
          }
        });

        if (skinnedMesh) {
          morphDict = skinnedMesh.morphTargetDictionary;
          morphInfluences = skinnedMesh.morphTargetInfluences;
          console.log("Available morph targets:", Object.keys(morphDict));

          if ('mouthSmile' in morphDict) {
            morphInfluences[morphDict['mouthSmile']] = 0.3;
            console.log("Applied mouthSmile blend shape");
          }

          if ('eyesClosed' in morphDict) {
            function blinkEyes(i) {
              morphInfluences[i] = 1;
              setTimeout(() => morphInfluences[i] = 0, 100);
              console.log("Eyes blinked");
            }

            const eyeIndex = morphDict['eyesClosed'];
            setInterval(() => {
              blinkEyes(eyeIndex);
            }, 5000 + Math.random() * 2000);
          }
        } else {
          console.warn("No skinned mesh with morph targets found");
        }

        const box = new THREE.Box3().setFromObject(model);
        const center = box.getCenter(new THREE.Vector3());
        console.log('Initial Center Point:', center);

        function animate() {
          requestAnimationFrame(animate);
          controls.update();
          renderer.render(scene, camera);
          if (model) {
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
          }
        }

        animate();
      }, undefined, function (error) {
        console.error('Error loading GLB model:', error);
        document.getElementById('questionText').textContent = 'Error loading the 3D model.';
      });

      window.addEventListener('resize', () => {
        const newBounds = container.getBoundingClientRect();
        camera.aspect = newBounds.width / newBounds.height;
        camera.updateProjectionMatrix();
        renderer.setSize(newBounds.width, newBounds.height);
      });
    }
    initAvatar();

    async function speakWithElevenLabs(text) {
      try {
        const response = await fetch('/api/tts', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text, voice_id: 'pNInz6obpgDQGcFmaJgB' })
        });
        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(`TTS request failed: ${errorData.error || response.statusText}`);
        }
        const audioBlob = await response.blob();
        const audioUrl = URL.createObjectURL(audioBlob);
        const audio = new Audio(audioUrl);
        audio.play();
        audio.onplay = () => {
          isSpeaking = true;
          playTalkingAnimation();
          startMouthAnimation();
        };
        audio.onended = () => {
          isSpeaking = false;
          stopTalkingAnimation();
          stopMouthAnimation();
          URL.revokeObjectURL(audioUrl);
        };
      } catch (error) {
        console.error('TTS error:', error.message);
        document.getElementById('questionText').textContent += ` (Voice service failed: ${error.message})`;
      }
    }

    function speakQuestion(text) {
      if (!text || typeof text !== "string") return;
      const noEmojiText = text.replace(/[\p{Emoji_Presentation}\p{Extended_Pictographic}]/gu, '');
      speakWithElevenLabs(noEmojiText);
    }

    function correctSpelling(userInput) {
      let inputLower = userInput.toLowerCase();
      const corrections = {
        'ubeek': 'UBIK',
        'ubiik': 'UBIK',
        'youbik': 'UBIK',
        'ethiglo': 'EthiGlo',
        'ethi glo': 'EthiGlo',
        'ethiglow': 'EthiGlo',
        'ethigloo': 'EthiGlo',
        'sisonext': 'SisoNext',
        'tehnology': 'technology',
        'wat': 'what',
        'prodacts': 'products',
        'soultion': 'solution'
      };
      for (let wrong in corrections) {
        const pattern = new RegExp(`\\b${wrong}\\b`, 'gi');
        inputLower = inputLower.replace(pattern, corrections[wrong]);
      }
      return inputLower.charAt(0).toUpperCase() + inputLower.slice(1);
    }

    function displayQuestion() {
      if (currentQuestion < totalQuestions && questions[currentQuestion]) {
        document.getElementById('questionNumber').textContent = currentQuestion + 1;
        document.getElementById('questionText').textContent = questions[currentQuestion].question;
        const optionsDiv = document.getElementById('options');
        optionsDiv.innerHTML = '';
        questions[currentQuestion].options.forEach((option, index) => {
          const optionDiv = document.createElement('div');
          optionDiv.className = 'option';
          optionDiv.innerHTML = `
            <input type="radio" name="answer" id="option${index}" value="${option}">
            <label for="option${index}">${option}</label>
          `;
          optionsDiv.appendChild(optionDiv);
        });
        speakQuestion(questions[currentQuestion].question);
        document.getElementById('results').style.display = 'none';
        document.getElementById('summary-report').style.display = 'none';
        document.getElementById('question-area').style.display = 'block';
        document.getElementById('options').parentElement.style.display = 'flex';
      } else {
        evaluateQuiz();
      }
    }

    function repeatQuestion() {
      if (currentQuestion < totalQuestions && questions[currentQuestion]) {
        speakQuestion(questions[currentQuestion].question);
      }
    }

    function submitAnswer() {
      const selectedOption = document.querySelector('input[name="answer"]:checked');
      if (!selectedOption) return;
      const answer = correctSpelling(selectedOption.value);
      answers.push({
        question: questions[currentQuestion].question,
        answer,
        options: questions[currentQuestion].options
      });
      currentQuestion++;
      displayQuestion();
    }

    function skipQuestion() {
      answers.push({
        question: questions[currentQuestion].question,
        answer: 'SKIPPED',
        options: questions[currentQuestion].options
      });
      currentQuestion++;
      displayQuestion();
    }

    const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
    recognition.lang = 'en-US';
    recognition.interimResults = false;
    recognition.continuous = false;

    function startListening() {
      recognition.start();
      isListening = true;
      stopTalkingAnimation();
      stopMouthAnimation();
      document.getElementById('waveform').style.display = 'block';
    }

    recognition.onresult = function(event) {
      let transcript = event.results[0][0].transcript;
      transcript = correctSpelling(transcript);
      const options = questions[currentQuestion].options;
      const closestOption = options.reduce((prev, curr) =>
        Math.abs(curr.toLowerCase().indexOf(transcript.toLowerCase())) < Math.abs(prev.toLowerCase().indexOf(transcript.toLowerCase())) ? curr : prev
      );
      document.querySelector(`input[value="${closestOption}"]`).checked = true;
      submitAnswer();
      isListening = false;
      document.getElementById('waveform').style.display = 'none';
    };

    recognition.onerror = function(event) {
      console.error('Speech recognition error:', event.error);
      document.getElementById('questionText').textContent += " (Couldn't hear properly. Try again.)";
      isListening = false;
      document.getElementById('waveform').style.display = 'none';
    };

    recognition.onend = function() {
      isListening = false;
      document.getElementById('waveform').style.display = 'none';
    };

    fetch('/api/quiz-questions')
      .then(res => {
        if (!res.ok) throw new Error('Failed to fetch questions');
        return res.json();
      })
      .then(data => {
        questions = data;
        console.log('Fetched questions:', questions);
        displayQuestion();
      }).catch(err => {
        console.error('Error fetching questions:', err);
        document.getElementById('questionText').textContent = 'Error loading questions.';
      });

    async function evaluateQuiz() {
      document.getElementById('question-area').style.display = 'none';
      document.getElementById('options').parentElement.style.display = 'none';
      document.getElementById('results').style.display = 'none';
      document.getElementById('summary-report').style.display = 'block';

      let totalScore = 0;
      let correctAnswers = 0;
      let summaryText = `<h3>UBIK Solutions Quiz Performance Report</h3>`;
      summaryText += `<strong>Overall Performance</strong><br>`;

      for (let i = 0; i < answers.length; i++) {
        const { question, answer, options } = answers[i];
        try {
          const response = await fetch('/api/evaluate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ question, answer, options })
          });
          const data = await response.json();
          console.log(`Evaluation response for Q${i + 1}:`, data);
          if (data.feedback && typeof data.score === 'number') {
            totalScore += data.score;
            if (data.score >= 0.8) correctAnswers++;
            summaryText += `<strong>Question ${i + 1}: ${question}</strong><br>`;
            summaryText += `Your Answer: ${answer === 'SKIPPED' ? 'Skipped' : answer}<br>`;
            summaryText += `Feedback: ${data.feedback}<br>`;
            summaryText += `Score: ${(data.score * 10).toFixed(2)}/10<br>`;
            summaryText += `Reference: ${data.reference || 'Refer to UBIK Solutions’ official resources for more details.'}<br><br>`;
          } else {
            summaryText += `<strong>Question ${i + 1}: ${question}</strong><br>`;
            summaryText += `Your Answer: ${answer === 'SKIPPED' ? 'Skipped' : answer}<br>`;
            summaryText += `Feedback: Error evaluating answer; please try again.<br>`;
            summaryText += `Score: 0/10<br>`;
            summaryText += `Reference: Unable to evaluate due to API error.<br><br>`;
          }
        } catch (err) {
          console.error(`Error evaluating Q${i + 1}:`, err);
          summaryText += `<strong>Question ${i + 1}: ${question}</strong><br>`;
          summaryText += `Your Answer: ${answer === 'SKIPPED' ? 'Skipped' : answer}<br>`;
          summaryText += `Feedback: Error evaluating answer; please try again.<br>`;
          summaryText += `Score: 0/10<br>`;
          summaryText += `Reference: Unable to evaluate due to API error.<br><br>`;
        }
      }

      const avg = answers.length ? (totalScore / answers.length).toFixed(2) : 0;
      const percentage = answers.length ? ((avg / 1.0) * 100).toFixed(0) : 0;
      summaryText += `<strong>Average Score: ${avg}/1.0 (${percentage}%)</strong><br>`;
      summaryText += `Correct Answers: ${correctAnswers} out of ${answers.length}<br><br>`;

      const strengths = [];
      for (let i = 0; i < answers.length; i++) {
        const { question, answer } = answers[i];
        const feedback = document.getElementById('summary-content').innerHTML.includes(`Question ${i + 1}`)
          ? document.getElementById('summary-content').innerHTML.match(new RegExp(`Question ${i + 1}.*?Feedback: (.*?)<br>`))[1]
          : '';
        if (feedback.toLowerCase().includes('correct') || (answer !== 'SKIPPED' && feedback.includes('UBIK'))) {
          if (question.toLowerCase().includes('anti-acne')) {
            strengths.push('Strong understanding of UBIK Solutions’ Anti-Acne product line, such as Sebogel.');
          } else if (question.toLowerCase().includes('anti-ageing') || question.toLowerCase().includes('aging')) {
            strengths.push('Solid knowledge of UBIK Solutions’ Anti-Ageing products, such as Reti K Cream.');
          } else {
            strengths.push('Good grasp of UBIK Solutions’ services or mission, such as AI-driven dermatology.');
          }
        }
      }
      summaryText += `<strong>Strengths</strong><br>`;
      if (strengths.length > 0) {
        summaryText += `Your performance demonstrates the following strengths:<br>`;
        strengths.forEach(s => summaryText += `- ${s}<br>`);
      } else {
        summaryText += `No specific strengths identified due to limited correct answers. Consider reviewing UBIK Solutions’ offerings for improvement.<br>`;
      }
      summaryText += `<br>`;

      const improvements = [];
      for (let i = 0; i < answers.length; i++) {
        const { question, answer } = answers[i];
        const feedback = document.getElementById('summary-content').innerHTML.includes(`Question ${i + 1}`)
          ? document.getElementById('summary-content').innerHTML.match(new RegExp(`Question ${i + 1}.*?Feedback: (.*?)<br>`))[1]
          : '';
        if (answer === 'SKIPPED' || feedback.toLowerCase().includes('incorrect') || feedback.toLowerCase().includes('incomplete')) {
          if (question.toLowerCase().includes('anti-acne')) {
            improvements.push('Deepen your knowledge of UBIK Solutions’ Anti-Acne products, such as Sebogel’s ingredients (e.g., Salicylic Acid, Niacinamide).');
          } else if (question.toLowerCase().includes('anti-ageing') || question.toLowerCase().includes('aging')) {
            improvements.push('Learn more about UBIK Solutions’ Anti-Ageing products, such as Reti K Cream with Encapsulated Retinol.');
          } else {
            improvements.push('Review UBIK Solutions’ services or mission, such as AI dermatology applications or iDoc Academy.');
          }
        }
      }
      summaryText += `<strong>Areas for Improvement</strong><br>`;
      if (improvements.length > 0) {
        summaryText += `To enhance your understanding, focus on the following areas:<br>`;
        improvements.forEach(i => summaryText += `- ${i}<br>`);
      } else {
        summaryText += `No major areas for improvement identified. Continue to build on your strong performance.<br>`;
      }
      summaryText += `<br>`;

      summaryText += `<strong>Recommendations for Growth</strong><br>`;
      if (avg >= 0.8) {
        summaryText += `Your strong performance indicates a solid understanding of UBIK Solutions. To maintain and expand your knowledge, consider exploring advanced topics, such as the technical aspects of AI in dermatology or the formulation of products like Sebogel and Reti K Cream.<br>`;
      } else if (avg >= 0.5) {
        summaryText += `You have a good foundation in UBIK Solutions’ offerings. To improve, study key areas such as Anti-Acne and Anti-Ageing product details or the role of AI in our services. Reviewing the UBIK Solutions website or training materials can help.<br>`;
      } else {
        summaryText += `Your performance suggests a need for deeper familiarity with UBIK Solutions. Focus on understanding our core products (e.g., Anti-Acne, Anti-Ageing) and services (e.g., AI dermatology, iDoc Academy). Retaking the quiz after reviewing our data is recommended.<br>`;
      }
      summaryText += `For further learning, explore UBIK Solutions’ official resources at <a href="https://www.ubiksolution.com" target="_blank">https://www.ubiksolution.com</a> or contact our training team for detailed product and service information.<br>`;

      document.getElementById('summary-content').innerHTML = summaryText;
    }
  </script>
</body>
</html>